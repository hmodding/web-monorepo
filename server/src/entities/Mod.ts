import {
  AfterLoad,
  Column,
  Entity,
  JoinTable,
  ManyToMany,
  OneToMany,
  OneToOne,
  PrimaryColumn,
} from 'typeorm';
import {ModCategory} from '../../../shared/types/ModCategory';
import {AbstractEntityWithCreatedAndUpdated} from './AbstractEntity';
import {ModVersion} from './ModVersion';
import {ScheduledModDeletion} from './ScheduledModDeletion';
import {User} from './User';

@Entity({name: 'mods'})
export class Mod extends AbstractEntityWithCreatedAndUpdated {
  @PrimaryColumn({unique: true, length: 64})
  id!: string; //NO AUTOGENERATED ID!

  @Column()
  title!: string;

  @Column()
  description!: string;

  @Column({type: 'text'})
  readme!: string;

  @Column()
  category!: ModCategory;

  @Column()
  author!: string;

  @Column({type: 'text', nullable: true})
  bannerImageUrl?: string;

  @Column({type: 'text', nullable: true})
  repositoryUrl?: string;

  @Column({type: 'text', nullable: true})
  iconImageUrl?: string;

  @OneToMany(() => ModVersion, (version) => version.mod)
  versions?: ModVersion[];

  @OneToOne(() => ScheduledModDeletion)
  scheduledDeletion?: ScheduledModDeletion;

  @ManyToMany(() => User, (user) => user.likedMods)
  @JoinTable({
    name: 'ModLikes',
    joinColumn: {
      name: 'modId',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'userId',
      referencedColumnName: 'id',
    },
  })
  likes?: User[];

  likeCount: number = 0;

  //hooks

  @AfterLoad()
  calculateLikeCount() {
    this.likeCount = this.likes?.length || this.likeCount;
  }

  /*TODO: -- see if this needs implementation: --
    async beforeFind(findOptions: FindOptions): Promise<void> {
    const modsToDelete = await scheduledModDeletionModel.findAll();
    const excludedIds = modsToDelete.map(({ modId }) => modId);

    findOptions.where = {
      ...findOptions.where,
      id: { [Op.notIn]: excludedIds },
    };

    const includes = Array.isArray(findOptions.include)
      ? findOptions.include
      : [findOptions.include];
    const versionsInclude =
      includes.find(
        (include) => (include as Association)?.as === 'versions',
      ) || null;

    if (versionsInclude) {
      findOptions.order = [['versions', 'createdAt', 'desc']];
    } else {
      findOptions.order = [['createdAt', 'desc']];
    }
  },
  */
}
